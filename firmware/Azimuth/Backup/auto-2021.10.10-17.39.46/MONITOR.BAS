'**********************************************************************************************************
'PROJECT: LSPE-STRIP
'
'TrioController: AZIMUTH
'Program: MONITOR
'
'Description
'   This program monitors the system for faults/errors and reacts/recovers accordingly.
'   It is run from STARTUP as process 2.
'   The main program is started when there are no faults, and is stopped if a fault is detected.
'**********************************************************************************************************

INCLUDE "COMMON" 'include I/O and VR constants and parameters
ignore_basic_err=FALSE 'Before the program terminates we set the 'ignore_basic_err' flag to prevent
'an error message being generated by a normal program termination.

ON BASICERROR GOSUB basic_err
PRINT#5,"MONITOR Program Running"
VR(fault_status)=no_fault
VR(fault_acknowledge)=OFF
GOSUB clear_axis_errors

IF PROC_STATUS PROC(5) =0 THEN RUN "ENCODER_UPDATE",5
WAIT UNTIL PROC_STATUS PROC(5)=1
IF PROC_STATUS PROC(3) = 0 THEN RUN "MAIN",3
WAIT UNTIL PROC_STATUS PROC(3)=1
'IF PROC_STATUS PROC(4) = 0 THEN RUN "VR_UPDATE",4
'WAIT UNTIL PROC_STATUS PROC(4)=1
WA(100)

REPEAT
    'Check for emergency stop
    IF IN(in_estop_healthy)=OFF THEN
        VR(fault_status)=estop

        'Check for axis faults
    ELSE
        FOR ax = 0 TO axis_count
            IF AXISSTATUS AXIS(ax).2 = ON THEN VR(fault_status)=ax+11:fault_axis=ax 'Check for remote drive comm's fault
            IF AXISSTATUS AXIS(ax).3 = ON THEN VR(fault_status)=ax+15:fault_axis=ax 'Check for remote drive fault
            IF AXISSTATUS AXIS(ax).8 = ON THEN VR(fault_status)=ax+19:fault_axis=ax 'Check for FE limit
        NEXT ax
        IF WDOG=ON THEN 'Only check for axis errors when motors are enabled
            IF VR(mask_limits)=FALSE THEN
                FOR ax = 0 TO axis_count
                    IF AXISSTATUS AXIS(ax).4 = ON THEN VR(fault_status)=ax+3:fault_axis=ax 'Check for fwd HW limitswitch
                    IF AXISSTATUS AXIS(ax).5 = ON THEN VR(fault_status)=ax+7:fault_axis=ax 'Check for rev HW limitswitch
                NEXT ax
            ENDIF
        ENDIF
    ENDIF
    'IF CANIO_STATUS<>32 OR NIO<40 THEN VR(fault_status)=canio_fault 'Capture CAN I/O Faults  <-----------??? RIMETTERE
    IF VR(basic_err_fault)=TRUE THEN VR(fault_status)=basic_error 'Capture programming errors
    'If a fault is detected stop all motion
    IF VR(fault_status)<>no_fault THEN
        'fault_axis=ERROR_AXIS 'doesnt work if there are multiple axes in fault
        GOSUB stop_motion
        GOSUB fault_recovery
    ENDIF
    WA(10)
UNTIL 1<>1

STOP

'-------------------------------------------------------------------------------
'This sub-routine halts all motion tasks and programs
'-------------------------------------------------------------------------------
stop_motion:
RAPIDSTOP (2) 'Stop motion on all axis

FOR ax=0 TO axis_count 'Cancel all moves
    CANCEL(2) AXIS(ax)
NEXT ax

FOR ax=0 TO axis_count 'Wait for all axis to stop moving
    WAIT IDLE AXIS(ax)
NEXT ax

WDOG=OFF 'Disable all axis

VR(mask_basic_err)=TRUE
'Stop all motion programs
STOP "MAIN"

'Wait for all motion programs to stop
WAIT UNTIL PROC_STATUS PROC(3)=0
VR(mask_basic_err)=FALSE

'Turn off digital outputs
OP(out_relay_0,OFF)
OP(out_relay_1,OFF)
'Reset any user digital outputs here

VR(system_status)=fault
OP(out_fault_lamp,ON) 'Turn on fault lamp

RETURN

'-------------------------------------------------------------------------------
'This sub-routine handles acknowledgement and recovery from all faults
'-------------------------------------------------------------------------------
fault_recovery:
VR(fault_acknowledge)=OFF

IF VR(fault_status)=estop THEN 'Safety circuit tripped
    PRINT#5,"FAULT - E/STOP BUTTON PRESSED"
    WAIT UNTIL IN(in_estop_healthy)=ON 'Wait until safety circuit reset
    WA(2000) 'Time for PSU to recover
    GOSUB clear_axis_errors

'ELSEIF VR(fault_status)=canio_fault THEN 'CAN I/O Fault <------------ da rimettere una volta capito il CANBUS???????
'    PRINT#5,"FAULT - CAN I/O"
'    WAIT UNTIL VR(fault_acknowledge)=ON
'    CANIO_STATUS=16 'Re-initialise CAN IO Network
'    CANIO_ENABLE=1
'    WA(3000)
'    CANIO_STATUS=16
'    WA(2000)
'    GOSUB clear_axis_errors

ELSEIF VR(fault_status)>=3 AND VR(fault_status)<=10 THEN 'Axis Error
    IF VR(fault_status)>=3 AND VR(fault_status)<=6 THEN 'Forward HW limit switch hit
        PRINT#5,"FAULT - AXIS ";fault_axis;" FORWARD LIMIT SWITCH HIT"
        WAIT UNTIL VR(fault_acknowledge)=ON
        GOSUB clear_axis_errors
        'GOSUB move_off_fwd_limit

    ELSEIF VR(fault_status)>=7 AND VR(fault_status)<=10 THEN 'Reverse HW limit switch hit
        PRINT#5,"FAULT - AXIS ";fault_axis;" REVERSE LIMIT SWITCH HIT"
        WAIT UNTIL VR(fault_acknowledge)=ON
        GOSUB clear_axis_errors
        'GOSUB move_off_rev_limit
    ENDIF
ELSEIF VR(fault_status)>=11 AND VR(fault_status)<=14 THEN 'Remote axis comm's error
    PRINT#5,"FAULT - AXIS ";fault_axis;" ETHERCAT COMM'S ERROR"
    WAIT UNTIL VR(fault_acknowledge)=ON
    GOSUB reset_drive_fault
    GOSUB clear_axis_errors
ELSEIF VR(fault_status)>=15 AND VR(fault_status)<=18 THEN 'Remote axis error
    PRINT#5,"FAULT - AXIS ";fault_axis;" REMOTE DRIVE ERROR"
    WAIT UNTIL VR(fault_acknowledge)=ON
    GOSUB reset_drive_fault
    GOSUB clear_axis_errors
ELSEIF VR(fault_status)>=19 AND VR(fault_status)<=22 THEN 'Following Error Limit
    PRINT#5,"FAULT - AXIS ";fault_axis;" FOLLOWING ERROR LIMIT"
    WAIT UNTIL VR(fault_acknowledge)=ON
    GOSUB clear_axis_errors
ELSEIF VR(fault_status)=basic_error THEN
    PRINT #5,"FAULT - BASIC PROGRAMMING ERROR"
    WAIT UNTIL VR(fault_acknowledge)=ON
    GOSUB clear_axis_errors
ENDIF

PRINT#5,"FAULT CLEARED"
'VR(home_status)=not_homed 'comment out this line if absolute encoders being used and homing is not required
VR(home_status)=home_complete 'comment out this line if incremental encoders being used and homing is required
VR(mask_limits)=FALSE
VR(fault_status)=no_fault
OP(out_fault_lamp,OFF) 'turn off fault lamp
VR(fault_acknowledge)=OFF
IF PROC_STATUS PROC(3) = 0 THEN RUN "MAIN",3
WAIT UNTIL PROC_STATUS PROC(3)=1

RETURN

'-------------------------------------------------------------------------------
'This routine clears any existing axis errors and re enables
'-------------------------------------------------------------------------------
clear_axis_errors:
'Clear Axis Errors
WDOG=OFF
FOR ax=0 TO axis_count
    PRINT#5,"Clearing Axis ";ax;" errors"
    BASE(ax)
    CANCEL(2) 'Clear buffer
    WAIT IDLE
    DATUM(0) 'Clears the error bits for the FE, forward and reverse limit in AXIS_STATUS
    AXIS_ENABLE=ON 'Enables the axis (this parameter is ON by default)
    SERVO=ON 'Runs axis under servo control (as opposed to SERVO=OFF which runs it under open loop)
NEXT ax
'WDOG=ON '<------------------------WHY IS IT COMMENTED?? (FORSE PERCHÃ¨ NON VUOLE FAR RIPARTIRE GLI ASSI DOPO UN FAULT)
WA(250)
RETURN


'-------------------------------------------------------------------------------
'This routine resets the servo drive with a drive fault
'-------------------------------------------------------------------------------
reset_drive_fault:
BASE(fault_axis)
DRIVE_CW_MODE=1 'take manual control of the Control Word
DRIVE_CONTROLWORD = $06 'disable the drive hex 6
WA(10)
DRIVE_CONTROLWORD = $86 'reset the drive hex 86
WA(10)
DRIVE_CONTROLWORD = $06
DRIVE_CW_MODE=0 'auto control of the Control Word
RETURN


'-------------------------------------------------------------------------------
'This routine enables the operator to move the axis off of the forward limit switch
'-------------------------------------------------------------------------------
move_off_fwd_limit:
BASE(fault_axis)
WDOG=ON
WA(100)
SPEED=VR(((fault_axis+1)*100)+9) 'Set to relevant axis jogspeed and accel_decel
ACCEL=VR(((fault_axis+1)*100)+12)
DECEL=VR(((fault_axis+1)*100)+12)
TICKS=10000 'Set 10sec maximum time for axis to move of limit
MOVE(-VR(((fault_axis+1)*100)+22)) 'Set to axis limit_dist
WA(10)
WAIT UNTIL AXISSTATUS.4 = OFF OR TICKS <0 OR IDLE OR IN(in_estop_healthy)=OFF
WA(100)
CANCEL
WA(10)
WAIT IDLE
PRINT#5,"Axis ";fault_axis;" +limit fault cleared"
RETURN


'-------------------------------------------------------------------------------
'This routine enables the operator to move the axis off of the reverse limit switch
'-------------------------------------------------------------------------------
move_off_rev_limit:
BASE(fault_axis)
WDOG=ON
WA(100)
SPEED=VR(((fault_axis+1)*100)+9) 'Set to relevant axis jogspeed and accel_decel
ACCEL=VR(((fault_axis+1)*100)+12)
DECEL=VR(((fault_axis+1)*100)+12)
TICKS=10000 'Set 10sec maximum time for axis to move of limit
MOVE(VR(((fault_axis+1)*100)+22)) 'Set to axis limit_dist
WA(10)
WAIT UNTIL AXISSTATUS.5 = OFF OR TICKS <0 OR IDLE OR IN(in_estop_healthy)=OFF
WA(100)
CANCEL
WA(10)
WAIT IDLE
PRINT#5,"Axis ";fault_axis;" -limit fault cleared"
RETURN


'-------------------------------------------------------------------------------
'Programming Errors are trapped here.
'Before the program terminates we set the 'ignore_basic_err' flag to prevent
'an error message being generated by a normal program termination.
'-------------------------------------------------------------------------------
basic_err:
IF ignore_basic_err<>TRUE AND VR(mask_basic_err)<>TRUE THEN
    IF RUN_ERROR=31 THEN 'The program was stopped by the user
        PRINT#5,"MONITOR - PROGRAM ABORTED AT LINE ";ERROR_LINE
        STOP
    ELSE 'the program encountered a TrioBASIC programming error
        PRINT#5,"MONITOR - basic_err Error Line ";ERROR_LINE
        PRINT#5,"MONITOR - basic_err Run Error ";RUN_ERROR
    ENDIF
    VR(err_proc_no)=PROCNUMBER
    VR(err_line_no)=ERROR_LINE
    VR(err_code_no)=RUN_ERROR
    VR(basic_err_fault)=TRUE 'Signal fault to MONITOR program
    RAPIDSTOP (2) 'Stop motion on all axis
    FOR ax=0 TO axis_count 'Clear any buffered moves
        CANCEL(2) AXIS(ax)
    NEXT ax
    WA(10)
    FOR ax=0 TO axis_count 'Wait for all axis to stop
        WAIT IDLE AXIS(ax)
    NEXT ax

    WDOG=OFF
    WA(10)
    VR(fault_status)=basic_error 'set here because the program will now stop
ENDIF
STOP

RETURN




