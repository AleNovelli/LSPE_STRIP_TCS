'**********************************************************************************************************
'PROJECT: LSPE-STRIP
'
'TrioController: AZIMUTH
'Program: MONITOR
'
'Description
'   This program monitors the system for faults/errors and reacts/recovers accordingly.
'   It is run from STARTUP as process 2.
'   The main program is started when there are no faults, and is stopped if a fault is detected.
'**********************************************************************************************************

INCLUDE "COMMON" 'include I/O and VR constants and parameters
ignore_basic_err=FALSE 'Before the program terminates we set the 'ignore_basic_err' flag to prevent
'an error message being generated by a normal program termination.

ON BASICERROR GOSUB basic_err
PRINT#5,"MONITOR Program Running"
VR(fault_status)=no_fault
VR(fault_acknowledge)=OFF
GOSUB clear_axis_errors

IF PROC_STATUS PROC(5) =0 THEN RUN "ENCODER_UPDATE",5
WAIT UNTIL PROC_STATUS PROC(5)=1
IF PROC_STATUS PROC(3) = 0 THEN RUN "MAIN",3
WAIT UNTIL PROC_STATUS PROC(3)=1
'IF PROC_STATUS PROC(4) = 0 THEN RUN "VR_UPDATE",4
'WAIT UNTIL PROC_STATUS PROC(4)=1
WA(100)

REPEAT

    'reduce the workstation safety flag (it will be reset to a high value by the workstation periodically)
    VR(workstation_safety_flag)=VR(workstation_safety_flag)-1

    'reduce the master clock safety flag (it will be reset to a high value by ENCODER_UPDATE periodically every second)
    'VR(master_clock_safety_flag)=VR(master_clock_safety_flag)-1
    'NON PIù USATA

    'check if the connection to the worktation is stable
    'IF VR(workstation_safety_flag)<0 THEN
    '    VR(fault_status)=workstation
    'ENDIF

    'NON PIù USATA
    'check if the connection to the master clock is stable
    'IF VR(master_clock_safety_flag)<0 THEN
    '    VR(fault_status)=master_clock
    'ENDIF

    'Check for emergency stop
    IF IN(in_estop_healthy)=OFF THEN
        VR(fault_status)=estop


    ELSE 'Check for axis faults
        FOR ax = 0 TO axis_count
            IF AXISSTATUS AXIS(ax).2 = ON THEN VR(fault_status)=ax0_drv_comms_fault:fault_axis=ax 'Check for remote
'drive comm's fault
            IF AXISSTATUS AXIS(ax).3 = ON THEN VR(fault_status)=ax0_drive_fault:fault_axis=ax 'Check for remote drive
'fault
            IF AXISSTATUS AXIS(ax).8 = ON THEN VR(fault_status)=ax0_fe_fault:fault_axis=ax 'Check for FE limit
        NEXT ax

        'This section was commented out because there aren't limitswitch (hardware or software) to check for Azimuth ax
        'IF WDOG=ON THEN 'Only check for axis errors when motors are enabled
        '    IF VR(mask_limits)=FALSE THEN
        '        FOR ax = 0 TO axis_count
        '            IF AXISSTATUS AXIS(ax).4 = ON THEN VR(fault_status)=ax+3:fault_axis=ax'Check for fw HW limitswitch
        '            IF AXISSTATUS AXIS(ax).5 = ON THEN VR(fault_status)=ax+7:fault_axis=ax'Check for rev HW limitswitch
        '       NEXT ax
        '   ENDIF
        'ENDIF

    ENDIF
    'IF CANIO_STATUS<>32 OR NIO<40 THEN VR(fault_status)=canio_fault 'CAN I/O Faults<--COMMENTED BC NO CAN I/O CONNECTED

    IF VR(basic_err_fault)=TRUE THEN VR(fault_status)=basic_error 'Capture programming errors

    IF VR(motion_command)=stop_all THEN
        VR(system_status)=stopping
        GOSUB stop_motion
        WAIT UNTIL IDLE
        VR(motion_command)=await_all
        IF PROC_STATUS PROC(3) = 0 THEN RUN "MAIN",3
    ENDIF


    'If a fault is detected stop all motion
    IF VR(fault_status)<>no_fault THEN
        GOSUB stop_motion
        GOSUB fault_recovery
    ENDIF
    WA(10)
UNTIL FALSE

STOP

'-------------------------------------------------------------------------------
'This sub-routine halts all motion tasks and programs
'-------------------------------------------------------------------------------
stop_motion:
RAPIDSTOP (2) 'Stop motion on all axis

FOR ax=0 TO axis_count 'Cancel all moves
    CANCEL(2) AXIS(ax)
NEXT ax

FOR ax=0 TO axis_count 'Wait for all axis to stop moving
    WAIT IDLE AXIS(ax)
NEXT ax

WDOG=OFF 'Disable all axis

VR(mask_basic_err)=TRUE
'Stop all motion programs
STOP "MAIN"

'Wait for all motion programs to stop
WAIT UNTIL PROC_STATUS PROC(3)=0
VR(mask_basic_err)=FALSE

'Turn off digital outputs
OP(out_relay_0,OFF)
OP(out_relay_1,OFF)

'Reset any user digital outputs here
OP(io_user_modbus_table, OFF)
OP(io_user_azimuth_idle, OFF)

RETURN

'-------------------------------------------------------------------------------
'This sub-routine handles acknowledgement and recovery from all faults
'-------------------------------------------------------------------------------
fault_recovery:

VR(system_status)=fault
OP(out_fault_lamp,ON) 'Turn on fault lamp


VR(fault_acknowledge)=OFF

IF VR(fault_status)=estop THEN 'Safety circuit tripped
    PRINT#5,"FAULT - E/STOP BUTTON PRESSED"
    WAIT UNTIL IN(in_estop_healthy)=ON 'Wait until safety circuit reset
    WA(2000) 'Time for PSU to recover
    'WAIT UNTIL VR(fault_acknowledge)=ON
    GOSUB clear_axis_errors

'ELSEIF VR(fault_status)=canio_fault THEN 'CAN I/O Fault
'    PRINT#5,"FAULT - CAN I/O"
'    WAIT UNTIL VR(fault_acknowledge)=ON
'    CANIO_STATUS=16 'Re-initialise CAN IO Network
'    CANIO_ENABLE=1
'    WA(3000)
'    CANIO_STATUS=16
'    WA(2000)
'    GOSUB clear_axis_errors

'ELSEIF VR(fault_status)>=3 AND VR(fault_status)<=10 THEN 'Axis Error
'    IF VR(fault_status)>=3 AND VR(fault_status)<=6 THEN 'Forward HW limit switch hit
'        PRINT#5,"FAULT - AXIS ";fault_axis;" FORWARD LIMIT SWITCH HIT"
'        WAIT UNTIL VR(fault_acknowledge)=ON
'        GOSUB clear_axis_errors
'        'GOSUB move_off_fwd_limit
'
'    ELSEIF VR(fault_status)>=7 AND VR(fault_status)<=10 THEN 'Reverse HW limit switch hit
'        PRINT#5,"FAULT - AXIS ";fault_axis;" REVERSE LIMIT SWITCH HIT"
'        WAIT UNTIL VR(fault_acknowledge)=ON
'        GOSUB clear_axis_errors
'        'GOSUB move_off_rev_limit
'    ENDIF
ELSEIF VR(fault_status)=ax0_drv_comms_fault THEN 'Remote axis comm's error
    PRINT#5,"FAULT - AXIS ";fault_axis;" ETHERCAT COMM'S ERROR"
    WAIT UNTIL VR(fault_acknowledge)=ON
    GOSUB reset_drive_fault
    GOSUB clear_axis_errors
ELSEIF VR(fault_status)=ax0_drive_fault THEN 'Remote axis error
    PRINT#5,"FAULT - AXIS ";fault_axis;" REMOTE DRIVE ERROR"
    WAIT UNTIL VR(fault_acknowledge)=ON
    GOSUB reset_drive_fault
    GOSUB clear_axis_errors
ELSEIF VR(fault_status)=ax0_fe_fault THEN 'Following Error Limit
    PRINT#5,"FAULT - AXIS ";fault_axis;" FOLLOWING ERROR LIMIT"
    WAIT UNTIL VR(fault_acknowledge)=ON
    GOSUB clear_axis_errors
ELSEIF VR(fault_status)=basic_error THEN
    PRINT #5,"FAULT - BASIC PROGRAMMING ERROR"
    WAIT UNTIL VR(fault_acknowledge)=ON
    GOSUB clear_axis_errors
ELSEIF VR(fault_status)=encoder_samplig_fault THEN
    PRINT #5,"FAULT - ENCODER SAMPLING UPDATE ERROR"
    PRINT #5,"      - RESTART WITH LOWER UPDATE FREQ"
    STOP "ENCODER_UPDATE"
    WAIT UNTIL VR(fault_acknowledge)=ON
    RUN "ENCODER_UPDATE",5

ELSEIF VR(fault_status)=master_clock THEN
    PRINT #5,"FAULT - MASTER CLOCK DISCONNECTED"
    WAIT UNTIL IN(in_user_tos)=OFF
    WAIT UNTIL IN(in_user_tos)=ON
    WAIT UNTIL VR(fault_acknowledge)=ON
ELSEIF VR(fault_status)=workstation THEN
    PRINT #5,"FAULT - WORKSTATION DISCONNECTED"
    WAIT UNTIL VR(fault_acknowledge)=ON
ELSEIF VR(fault_status)=other_axis THEN
    PRINT #5,"FAULT - OTHER AXIS ERROR"
    WAIT UNTIL VR(fault_acknowledge)=ON
ELSEIF VR(fault_status)=sun_elongation THEN
    PRINT #5,"FAULT - SUN ELONGATION LIMIT"
    GOSUB increase_sun_elong
    OP(io_user_elevation_idle, ON)
    WAIT UNTIL IN(io_user_azimuth_idle)=OFF
    GOSUB park_avoid_sun
    WAIT UNTIL VR(fault_acknowledge)=ON
ELSE
    PRINT #5,"FAULT ", VR(fault_status),": UNKNOWN RECOVERY APPROACH"
    WAIT UNTIL VR(fault_acknowledge)=ON
    GOSUB clear_axis_errors
ENDIF

PRINT#5,"FAULT CLEARED"
'VR(home_status)=not_homed 'comment out this line if absolute encoders being used and homing is not required
VR(home_status)=home_complete 'comment out this line if incremental encoders being used and homing is required
VR(mask_limits)=FALSE
VR(fault_status)=no_fault
OP(out_fault_lamp,OFF) 'turn off fault lamp
VR(fault_acknowledge)=OFF
WA(2000)'wait so that we are shure that also the other axis has reached fault recovery
IF PROC_STATUS PROC(3) = 0 THEN RUN "MAIN",3
WAIT UNTIL PROC_STATUS PROC(3)=1

RETURN

'-------------------------------------------------------------------------------
'This routine clears any existing axis errors and re enables
'-------------------------------------------------------------------------------
clear_axis_errors:
'Clear Axis Errors
WDOG=OFF
FOR ax=0 TO axis_count
    PRINT#5,"Clearing Axis ";ax;" errors"
    BASE(ax)
    CANCEL(2) 'Clear buffer
    WAIT IDLE
    DATUM(0) 'Clears the error bits for the FE, forward and reverse limit in AXIS_STATUS
    AXIS_ENABLE=ON 'Enables the axis (this parameter is ON by default)
    SERVO=ON 'Runs axis under servo control (as opposed to SERVO=OFF which runs it under open loop)
NEXT ax
'WDOG=ON '<--- COMMENTED: I only want MAIN to be able to activate axis
WA(250)
RETURN


'-------------------------------------------------------------------------------
'This routine resets the servo drive with a drive fault
'-------------------------------------------------------------------------------
reset_drive_fault:
BASE(fault_axis)
DRIVE_CW_MODE=1 'take manual control of the Control Word
DRIVE_CONTROLWORD = $06 'disable the drive hex 6
WA(10)
DRIVE_CONTROLWORD = $86 'reset the drive hex 86
WA(10)
DRIVE_CONTROLWORD = $06
DRIVE_CW_MODE=0 'auto control of the Control Word
RETURN


'-------------------------------------------------------------------------------
'This routine moves the telescope away from the sun and into parking
'-------------------------------------------------------------------------------
increase_sun_elong:
WDOG=ON
SPEED=VR(ax0_jogspeed)
ticks_at_sun_fault=TICKS
WHILE VR(fault_acknowledge)=OFF AND TICKS-ticks_at_sun_fault<30*SERVO_PERIOD
    WA(SERVO_PERIOD)
WEND
WDOG=ON
MOVE(VR(antisun_direction)*90)
WHILE VR(fault_acknowledge)=OFF AND TICKS-ticks_at_sun_fault<1*60*SERVO_PERIOD
    WA(SERVO_PERIOD)
WEND
CANCEL
WAIT IDLE
RETURN

'-------------------------------------------------------------------------------
'Move to park
'-------------------------------------------------------------------------------
park_avoid_sun:
PRINT#5,"Moving to park"
WDOG=ON
'Setup axis speeds
SPEED=VR(ax0_move_speed)
ACCEL=VR(ax0_accel_decel)
DECEL=VR(ax0_accel_decel)
BASE(ax0)
TRIGGER

IF VR(jog_traj_lenght)>9 THEN
    VR(basic_err_fault)=TRUE
    VR(err_proc_no)=PROCNUMBER
    VR(err_line_no)=PROC_LINE PROC(PROCNUMBER)
    VR(err_code_no)=-1
ENDIF


FOR pos=1 TO VR(jog_traj_lenght)-1: 'cicling over the positions of the trajectory
    'if the step of the trajectory changes Alt and not Az wait for Alt motor to be idle
    IF VR(jog_traj+pos)=VR(jog_traj+pos-1) THEN
        PRINT #5, "Waiting for elevation to be idle"
        PRINT #5, VR(jog_traj+pos-1), "--->", VR(jog_traj+pos)
        WA(20)
        WAIT UNTIL IN(in_user_elevation_idle)
        OP(in_user_elevation_idle, OFF)
    ELSE 'if instead the step of the trajectory changes Az
        PRINT #5, "Moving:"
        PRINT #5, VR(jog_traj+pos-1), "--->", VR(jog_traj+pos)

        WAIT UNTIL IN(io_user_azimuth_idle)=OFF

        'if the desired pos - current pos is more than 180deg the motor should roll around the -180deg,180deg limit
        IF ABS (VR(jog_traj+pos)-MPOS)>(VR(ax0_units_rev)/2) THEN
            'since MOVEABS odes not take into consideration the rollover at 180deg we must add the
            ' following motions to move the azimuth past the rollover if it is needed
            IF MPOS>=0 THEN
                MOVE(180-MPOS+1)
                WAIT IDLE
            ELSE
                MOVE(-(180+MPOS)-1)
                WAIT IDLE
            ENDIF
        ENDIF

        MOVEABS( VR(jog_traj+pos) ) 'move the motor in position
        WAIT IDLE 'wait end of motion
        OP(io_user_azimuth_idle, ON) 'signal that the motor is idle to workstation and Alt TrioController
    ENDIF
NEXT pos

TRIGGER
PRINT#5,"Telescope in starting position"
RETURN


'-------------------------------------------------------------------------------
'Programming Errors are trapped here.
'Before the program terminates we set the 'ignore_basic_err' flag to prevent
'an error message being generated by a normal program termination.
'-------------------------------------------------------------------------------
basic_err:
IF ignore_basic_err<>TRUE AND VR(mask_basic_err)<>TRUE THEN
    IF RUN_ERROR=31 THEN 'The program was stopped by the user
        PRINT#5,"MONITOR - PROGRAM ABORTED AT LINE ";ERROR_LINE
        STOP
    ELSE 'the program encountered a TrioBASIC programming error
        PRINT#5,"MONITOR - basic_err Error Line ";ERROR_LINE
        PRINT#5,"MONITOR - basic_err Run Error ";RUN_ERROR
    ENDIF
    VR(err_proc_no)=PROCNUMBER
    VR(err_line_no)=ERROR_LINE
    VR(err_code_no)=RUN_ERROR
    VR(basic_err_fault)=TRUE 'Signal fault to MONITOR program
    RAPIDSTOP (2) 'Stop motion on all axis
    FOR ax=0 TO axis_count 'Clear any buffered moves
        CANCEL(2) AXIS(ax)
    NEXT ax
    WA(10)
    FOR ax=0 TO axis_count 'Wait for all axis to stop
        WAIT IDLE AXIS(ax)
    NEXT ax

    WDOG=OFF
    WA(10)
    VR(fault_status)=basic_error 'set here because the program will now stop
ENDIF
STOP

RETURN

